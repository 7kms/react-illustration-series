<!DOCTYPE html><html><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="keywords" content="react, react原理, 图解react, react fiber原理, react hook原理, react 合成事件, react 基本包结构">
<meta name="description" content="图解React原理系列, 以react核心包结构和运行机制为主线索进行展开. 包括react 基本包结构, react 工作循环, react 启动模式, react fiber原理, react hook原理, react 合成事件等核心内容">
<link rel="shortcut icon" href="/km@2x.png">
<link rel="stylesheet" href="/umi.eb36fa83.css">
<title data-rh="true">调和算法</title>
<meta data-rh="true" property="og:title" content="调和算法"/><meta data-rh="true" name="description" content="调和函数(源码)是在fiber树构(对比更新)过程中对旧fiber节点与新reactElement进行比较, 判定旧fiber节点是否可以复用的一个比较函数."/><meta data-rh="true" property="og:description" content="调和函数(源码)是在fiber树构(对比更新)过程中对旧fiber节点与新reactElement进行比较, 判定旧fiber节点是否可以复用的一个比较函数."/>
</head>
<body>
<noscript><b>Enable JavaScript to run this app.</b></noscript><div id="root"><!--$?--><template id="B:0"></template><div></div><!--/$--></div><script>window.__UMI_LOADER_DATA__ = {}</script>
<script src="/umi.c14ba5aa.js"></script>

</body></html><div hidden id="S:0"><!--$?--><template id="B:1"></template><div></div><!--/$--></div><script>function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("B:0","S:0")</script><div hidden id="S:1"><div class="dumi-default-doc-layout"><div class="dumi-default-header"><div class="dumi-default-header-content"><section class="dumi-default-header-left"><a class="dumi-default-logo" href="/"><img src="/logo.png" alt="图解React"/>图解React<!-- --></a></section><section class="dumi-default-header-right"><ul class="dumi-default-navbar"><li><a href="/main/macro-structure">原理解析</a></li><li><a class="active" href="/algorithm/diff">高频算法</a></li><li><a href="/interview/01-setstate">面试题</a></li></ul><div class="dumi-default-header-right-aside"><div class="dumi-default-search-bar"><svg viewBox="64 64 896 896" class="dumi-default-search-bar-svg"><path d="M909.6 854.5 649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0 0 11.6 0l43.6-43.5a8.2 8.2 0 0 0 0-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z"></path></svg><input class="dumi-default-search-bar-input" placeholder="输入关键字搜索..."/><span class="dumi-default-search-shortcut">⌘<!-- --> K<!-- --></span></div><span class="dumi-default-color-switch" data-dumi-tooltip="亮色模式" data-dumi-tooltip-bottom="true"><svg viewBox="0 0 16 16"><path d="M8 13a1 1 0 0 1 1 1v1a1 1 0 1 1-2 0v-1a1 1 0 0 1 1-1ZM8 3a1 1 0 0 1-1-1V1a1 1 0 1 1 2 0v1a1 1 0 0 1-1 1Zm7 4a1 1 0 1 1 0 2h-1a1 1 0 1 1 0-2h1ZM3 8a1 1 0 0 1-1 1H1a1 1 0 1 1 0-2h1a1 1 0 0 1 1 1Zm9.95 3.536.707.707a1 1 0 0 1-1.414 1.414l-.707-.707a1 1 0 0 1 1.414-1.414Zm-9.9-7.072-.707-.707a1 1 0 0 1 1.414-1.414l.707.707A1 1 0 0 1 3.05 4.464Zm9.9 0a1 1 0 0 1-1.414-1.414l.707-.707a1 1 0 0 1 1.414 1.414l-.707.707Zm-9.9 7.072a1 1 0 0 1 1.414 1.414l-.707.707a1 1 0 0 1-1.414-1.414l.707-.707ZM8 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm0 6.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5Z"></path></svg><select><option value="light" selected="">亮色模式<!-- --></option><option value="dark">暗色模式<!-- --></option><option value="auto">跟随系统<!-- --></option></select></span><a class="dumi-default-icon" data-dumi-tooltip="GitHub" data-dumi-tooltip-bottom="true" target="_blank" href="https://github.com/7kms/react-illustration-series" rel="noreferrer"><svg viewBox="64 64 896 896"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></a></div></section><button type="button" class="dumi-default-header-menu-btn"><svg viewBox="64 64 896 896"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></button></div></div><div class="dumi-default-doc-layout-mobile-bar"><button type="button" class="dumi-default-sidebar-btn"><svg viewBox="64 64 896 896"><path d="M120 230h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm0 424h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm784 140H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0-424H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8z"></path></svg>侧边菜单<!-- --></button></div><main><div class="dumi-default-sidebar"><dl class="dumi-default-sidebar-group"><dd><a title="调和算法" aria-current="page" class="active" href="/algorithm/diff">调和算法</a></dd><dd><a title="位运算" class="" href="/algorithm/bitfield">位运算</a></dd><dd><a title="深度优先遍历" class="" href="/algorithm/dfs">深度优先遍历</a></dd><dd><a title="堆排序" class="" href="/algorithm/heapsort">堆排序</a></dd><dd><a title="链表操作" class="" href="/algorithm/linkedlist">链表操作</a></dd><dd><a title="栈操作" class="" href="/algorithm/stack">栈操作</a></dd></dl></div><div class="dumi-default-content"><!--$?--><template id="B:2"></template><div></div><!--/$--><div class="dumi-default-footer">Copyright © 2023 | Powered by <a href="https://d.umijs.org" target="_blank" rel="noreferrer">dumi</a></div></div></main></div></div><script>$RC("B:1","S:1")</script><div hidden id="S:2"><div class="markdown"><h1 id="react-算法之调和算法"><a aria-hidden="true" tabindex="-1" href="#react-算法之调和算法"><span class="icon icon-link"></span></a>React 算法之调和算法<!-- --></h1><h2 id="概念"><a aria-hidden="true" tabindex="-1" href="#概念"><span class="icon icon-link"></span></a>概念<!-- --></h2><p>调和函数(<!-- --><a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L1274-L1410">源码</a>)是在<!-- --><code>fiber树构(对比更新)</code>过程中对<!-- --><code>旧fiber节点</code>与<!-- --><code>新reactElement</code>进行比较, 判定<!-- --><code>旧fiber节点</code>是否可以复用的一个比较函数.<!-- --></p><p>调和函数仅是<!-- --><code>fiber树构造</code>过程中的一个环节, 所以在深入理解这个函数之前, 建议对<!-- --><code>fiber树构造</code>有一个宏观的理解(可以参考前文<!-- --><a href="/main/fibertree-create">fiber 树构造(初次创建)</a>, <!-- --><a href="/main/fibertree-update">fiber 树构造(对比更新)</a>), 本节重点探讨其算法的实现细节.<!-- --></p><p>它的主要作用:</p><ol><li>给新增,移动,和删除节点设置<!-- --><code>fiber.flags</code>(新增, 移动: <!-- --><code>Placement</code>, 删除: <!-- --><code>Deletion</code>)<!-- --></li><li>如果是需要删除的<!-- --><code>fiber</code>, <!-- --><a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L275-L294">除了自身打上<!-- --><code>Deletion</code>之外, 还要将其添加到父节点的<!-- --><code>effects</code>链表中<!-- --></a>(正常副作用队列的处理是在<!-- --><code>completeWork</code>函数, 但是该节点(被删除)会脱离<!-- --><code>fiber</code>树, 不会再进入<!-- --><code>completeWork</code>阶段, 所以在<!-- --><code>beginWork</code>阶段提前加入副作用队列).<!-- --></li></ol><h2 id="特性"><a aria-hidden="true" tabindex="-1" href="#特性"><span class="icon icon-link"></span></a>特性<!-- --></h2><p>算法复杂度低, 从上至下比较整个树形结构, 时间复杂度被缩短到 O(n)</p><h2 id="基本原理"><a aria-hidden="true" tabindex="-1" href="#基本原理"><span class="icon icon-link"></span></a>基本原理<!-- --></h2><ol><li>比较对象: <!-- --><code>fiber</code>对象与<!-- --><code>ReactElement</code>对象相比较.
<!-- --><ul><li>注意: 此处有一个误区, 并不是两棵 fiber 树相比较, 而是<!-- --><code>旧fiber</code>对象与<!-- --><code>新ReactElement</code>对象向比较, 结果生成新的<!-- --><code>fiber子节点</code>.<!-- --></li><li>可以理解为输入<!-- --><code>ReactElement</code>, 经过<!-- --><code>reconcileChildren()</code>之后, 输出<!-- --><code>fiber</code>.<!-- --></li></ul></li><li>比较方案:
<!-- --><ul><li>单节点比较</li><li>可迭代节点比较</li></ul></li></ol><h3 id="单节点比较"><a aria-hidden="true" tabindex="-1" href="#单节点比较"><span class="icon icon-link"></span></a>单节点比较<!-- --></h3><p>单节点的逻辑比较简明, 先直接看<!-- --><a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L1135-L1233">源码</a>:<!-- --></p><div class="dumi-default-source-code"><button type="button" class="dumi-default-source-code-copy"><svg viewBox="64 64 896 896"><path d="M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2 263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z"></path></svg></button><pre class="prism-code language-js"><div class=""><div class=""><span class="token comment">// 只保留主干逻辑</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">reconcileSingleElement</span><span class="token punctuation">(</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token parameter literal-property property">returnFiber</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter maybe-class-name">Fiber</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div></div><div class=""><div class=""><span class="token parameter">  </span><span class="token parameter literal-property property">currentFirstChild</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter maybe-class-name">Fiber</span><span class="token parameter"> </span><span class="token parameter operator">|</span><span class="token parameter"> </span><span class="token parameter keyword null nil">null</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div></div><div class=""><div class=""><span class="token parameter">  </span><span class="token parameter literal-property property">element</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter maybe-class-name">ReactElement</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div></div><div class=""><div class=""><span class="token parameter">  </span><span class="token parameter literal-property property">lanes</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter maybe-class-name">Lanes</span><span class="token parameter punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> key </span><span class="token operator">=</span><span class="token plain"> element</span><span class="token punctuation">.</span><span class="token property-access">key</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> child </span><span class="token operator">=</span><span class="token plain"> currentFirstChild</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">child </span><span class="token operator">!==</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token comment">// currentFirstChild !== null, 表明是对比更新阶段</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">child</span><span class="token punctuation">.</span><span class="token property-access">key</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> key</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token comment">// 1. key相同, 进一步判断 child.elementType === element.type</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token keyword control-flow">switch</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">child</span><span class="token punctuation">.</span><span class="token property-access">tag</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">        </span><span class="token comment">// 只看核心逻辑</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">        </span><span class="token keyword module">default</span><span class="token operator">:</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">          </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">child</span><span class="token punctuation">.</span><span class="token property-access">elementType</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> element</span><span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">            </span><span class="token comment">// 1.1 已经匹配上了, 如果有兄弟节点, 需要给兄弟节点打上Deletion标记</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">            </span><span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> child</span><span class="token punctuation">.</span><span class="token property-access">sibling</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">            </span><span class="token comment">// 1.2 构造fiber节点, 新的fiber对象会复用current.stateNode, 即可复用DOM对象</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">            </span><span class="token keyword">const</span><span class="token plain"> existing </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">useFiber</span><span class="token punctuation">(</span><span class="token plain">child</span><span class="token punctuation">,</span><span class="token plain"> element</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">            existing</span><span class="token punctuation">.</span><span class="token property-access">ref</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">coerceRef</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> child</span><span class="token punctuation">,</span><span class="token plain"> element</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">            existing</span><span class="token punctuation">.</span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> returnFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">            </span><span class="token keyword control-flow">return</span><span class="token plain"> existing</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">          </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">          </span><span class="token keyword control-flow">break</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">        </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token comment">// Didn&#x27;t match. 给当前节点点打上Deletion标记</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> child</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token keyword control-flow">break</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword control-flow">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token comment">// 2. key不相同, 匹配失败, 给当前节点打上Deletion标记</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token function">deleteChild</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> child</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    child </span><span class="token operator">=</span><span class="token plain"> child</span><span class="token punctuation">.</span><span class="token property-access">sibling</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token comment">// ...省略部分代码, 只看核心逻辑</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token comment">// 新建节点</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> created </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">createFiberFromElement</span><span class="token punctuation">(</span><span class="token plain">element</span><span class="token punctuation">,</span><span class="token plain"> returnFiber</span><span class="token punctuation">.</span><span class="token property-access">mode</span><span class="token punctuation">,</span><span class="token plain"> lanes</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  created</span><span class="token punctuation">.</span><span class="token property-access">ref</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">coerceRef</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> currentFirstChild</span><span class="token punctuation">,</span><span class="token plain"> element</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  created</span><span class="token punctuation">.</span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> returnFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> created</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token punctuation">}</span></div></div></pre></div><ol><li>如果是新增节点, 直接新建 fiber, 没有多余的逻辑</li><li>如果是对比更新
<!-- --><ul><li>如果<!-- --><code>key</code>和<!-- --><code>type</code>都相同(即: <!-- --><code>ReactElement.key</code> === <!-- --><code>Fiber.key</code> 且 <!-- --><code>Fiber.elementType === ReactElement.type</code>), 则复用<!-- --></li><li>否则新建</li></ul></li></ol><p>注意: 复用过程是调用<!-- --><code>useFiber(child, element.props)</code>创建<!-- --><code>新的fiber</code>对象, 这个<!-- --><code>新fiber对象.stateNode = currentFirstChild.stateNode</code>, 即<!-- --><code>stateNode</code>属性得到了复用, 故 DOM 节点得到了复用.<!-- --></p><h3 id="可迭代节点比较数组类型-symboliteratorfniteratorfn"><a aria-hidden="true" tabindex="-1" href="#可迭代节点比较数组类型-symboliteratorfniteratorfn"><span class="icon icon-link"></span></a>可迭代节点比较(数组类型, [Symbol.iterator]=fn,[@@iterator]=fn)<!-- --></h3><p>可迭代节点比较, 在<!-- --><a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L1346-L1362">源码中</a>被分为了 2 个部分:<!-- --></p><div class="dumi-default-source-code"><button type="button" class="dumi-default-source-code-copy"><svg viewBox="64 64 896 896"><path d="M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2 263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z"></path></svg></button><pre class="prism-code language-js"><div class=""><div class=""><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token parameter literal-property property">returnFiber</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter maybe-class-name">Fiber</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div></div><div class=""><div class=""><span class="token parameter">  </span><span class="token parameter literal-property property">currentFirstChild</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter maybe-class-name">Fiber</span><span class="token parameter"> </span><span class="token parameter operator">|</span><span class="token parameter"> </span><span class="token parameter keyword null nil">null</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div></div><div class=""><div class=""><span class="token parameter">  </span><span class="token parameter literal-property property">newChild</span><span class="token parameter operator">:</span><span class="token parameter"> any</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div></div><div class=""><div class=""><span class="token parameter">  </span><span class="token parameter literal-property property">lanes</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter maybe-class-name">Lanes</span><span class="token parameter punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token plain">newChild</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token function">reconcileChildrenArray</span><span class="token punctuation">(</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      returnFiber</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      currentFirstChild</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      newChild</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      lanes</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token function">getIteratorFn</span><span class="token punctuation">(</span><span class="token plain">newChild</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token function">reconcileChildrenIterator</span><span class="token punctuation">(</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      returnFiber</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      currentFirstChild</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      newChild</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      lanes</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token punctuation">}</span></div></div></pre></div><p>其中<!-- --><code>reconcileChildrenArray函数</code>(针对数组类型)和<!-- --><code>reconcileChildrenIterator</code>(针对可迭代类型)的核心逻辑几乎一致, 下文将分析<!-- --><a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L771-L924"><code>reconcileChildrenArray()</code>函数<!-- --></a>. 如果是新增节点, 所有的比较逻辑都无法命中, 只有<!-- --><code>对比更新</code>过程, 才有实际作用, 所以下文重点分析<!-- --><code>对比更新</code>的情况.<!-- --></p><div class="dumi-default-source-code"><button type="button" class="dumi-default-source-code-copy"><svg viewBox="64 64 896 896"><path d="M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2 263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z"></path></svg></button><pre class="prism-code language-js"><div class=""><div class=""><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">reconcileChildrenArray</span><span class="token punctuation">(</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token parameter literal-property property">returnFiber</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter maybe-class-name">Fiber</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div></div><div class=""><div class=""><span class="token parameter">  </span><span class="token parameter literal-property property">currentFirstChild</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter maybe-class-name">Fiber</span><span class="token parameter"> </span><span class="token parameter operator">|</span><span class="token parameter"> </span><span class="token parameter keyword null nil">null</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div></div><div class=""><div class=""><span class="token parameter">  </span><span class="token parameter literal-property property">newChildren</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter known-class-name class-name">Array</span><span class="token parameter operator">&lt;</span><span class="token parameter operator">*</span><span class="token parameter operator">&gt;</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div></div><div class=""><div class=""><span class="token parameter">  </span><span class="token parameter literal-property property">lanes</span><span class="token parameter operator">:</span><span class="token parameter"> </span><span class="token parameter maybe-class-name">Lanes</span><span class="token parameter punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> </span><span class="token literal-property property">resultingFirstChild</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> </span><span class="token literal-property property">previousNewFiber</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> oldFiber </span><span class="token operator">=</span><span class="token plain"> currentFirstChild</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> lastPlacedIndex </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">0</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> newIdx </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">0</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> nextOldFiber </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token comment">// 1. 第一次循环: 遍历最长公共序列(key相同), 公共序列的节点都视为可复用</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">for</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token plain"> oldFiber </span><span class="token operator">!==</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token plain"> </span><span class="token operator">&amp;&amp;</span><span class="token plain"> newIdx </span><span class="token operator">&lt;</span><span class="token plain"> newChildren</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span><span class="token plain"> newIdx</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token comment">// 后文分析</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">newIdx </span><span class="token operator">===</span><span class="token plain"> newChildren</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token comment">// 如果newChildren序列被遍历完, 那么oldFiber序列中剩余节点都视为删除(打上Deletion标记)</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> oldFiber</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">return</span><span class="token plain"> resultingFirstChild</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">oldFiber </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token comment">// 如果oldFiber序列被遍历完, 那么newChildren序列中剩余节点都视为新增(打上Placement标记)</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">for</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token plain"> newIdx </span><span class="token operator">&lt;</span><span class="token plain"> newChildren</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span><span class="token plain"> newIdx</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token comment">// 后文分析</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">return</span><span class="token plain"> resultingFirstChild</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token comment">// ==================分割线==================</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> existingChildren </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">mapRemainingChildren</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> oldFiber</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token comment">// 2. 第二次循环: 遍历剩余非公共序列, 优先复用oldFiber序列中的节点</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">for</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token plain"> newIdx </span><span class="token operator">&lt;</span><span class="token plain"> newChildren</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span><span class="token plain"> newIdx</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">shouldTrackSideEffects</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token comment">// newChildren已经遍历完, 那么oldFiber序列中剩余节点都视为删除(打上Deletion标记)</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    existingChildren</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token function">deleteChild</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> child</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> resultingFirstChild</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token punctuation">}</span></div></div></pre></div><p><code>reconcileChildrenArray</code>函数源码看似很长, 梳理其主干之后, 其实非常清晰.<!-- --></p><p>通过形参, 首先明确比较对象是<!-- --><code>currentFirstChild: Fiber | null</code>和<!-- --><code>newChildren: Array&lt;*&gt;</code>:<!-- --></p><ul><li><code>currentFirstChild</code>: 是一个<!-- --><code>fiber</code>节点, 通过<!-- --><code>fiber.sibling</code>可以将兄弟节点全部遍历出来. 所以可以将<!-- --><code>currentFirstChild</code>理解为链表头部, 它代表一个序列, 源码中被记为<!-- --><code>oldFiber</code>.<!-- --></li><li><code>newChildren</code>: 是一个数组, 其中包含了若干个<!-- --><code>ReactElement</code>对象. 所以<!-- --><code>newChildren</code>也代表一个序列.<!-- --></li></ul><p>所以<!-- --><code>reconcileChildrenArray</code>实际就是 2 个序列之间的比较(<!-- --><code>链表oldFiber</code>和<!-- --><code>数组newChildren</code>), 最后返回合理的<!-- --><code>fiber</code>序列.<!-- --></p><p>上述代码中, 以注释分割线为界限, 整个核心逻辑分为 2 步骤:</p><ol><li>第一次循环: 遍历最长<!-- --><code>公共</code>序列(key 相同), 公共序列的节点都视为可复用
<!-- --><ul><li>如果<!-- --><code>newChildren序列</code>被遍历完, 那么<!-- --><code>oldFiber序列</code>中剩余节点都视为删除(打上<!-- --><code>Deletion</code>标记)<!-- --></li><li>如果<!-- --><code>oldFiber序列</code>被遍历完, 那么<!-- --><code>newChildren序列</code>中剩余节点都视为新增(打上<!-- --><code>Placement</code>标记)<!-- --></li></ul></li><li>第二次循环: 遍历剩余<!-- --><code>非公共</code>序列, 优先复用 oldFiber 序列中的节点
<!-- --><ul><li>在对比更新阶段(非初次创建<!-- --><code>fiber</code>, 此时<!-- --><code>shouldTrackSideEffects</code>被设置为 true). 第二次循环遍历完成之后, <!-- --><code>oldFiber序列中</code>没有匹配上的节点都视为删除(打上<!-- --><code>Deletion</code>标记)<!-- --></li></ul></li></ol><p>假设有如下图所示 2 个初始化序列:</p><p><img alt="" src="/static/before-traverse.bdbb993b.png"/></p><p>接下来第一次循环, 会遍历公共序列<!-- --><code>A,B</code>, 生成的 fiber 节点<!-- --><code>fiber(A), fiber(B)</code>可以复用.<!-- --></p><p><img alt="" src="/static/traverse1.bd960700.png"/></p><p>最后第二次循环, 会遍历剩余序列<!-- --><code>E,C,X,Y</code>:<!-- --></p><ul><li>生成的 fiber 节点<!-- --><code>fiber(E), fiber(C)</code>可以复用. 其中<!-- --><code>fiber(C)</code>节点发生了位移(打上<!-- --><code>Placement</code>标记).<!-- --></li><li><code>fiber(X), fiber(Y)</code>是新增(打上<!-- --><code>Placement</code>标记).<!-- --></li><li>同时<!-- --><code>oldFiber</code>序列中的<!-- --><code>fiber(D)</code>节点确定被删除(打上<!-- --><code>Deletion</code>标记).<!-- --></li></ul><p><img alt="" src="/static/traverse2.435af340.png"/></p><p>整个主干逻辑就介绍完了, 接下来贴上完整源码</p><blockquote><p>第一次循环</p></blockquote><div class="dumi-default-source-code"><button type="button" class="dumi-default-source-code-copy"><svg viewBox="64 64 896 896"><path d="M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2 263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z"></path></svg></button><pre class="prism-code language-js"><div class=""><div class=""><span class="token comment">// 1. 第一次循环: 遍历最长公共 序列(key相同), 公共序列的节点都视为可复用</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token keyword control-flow">for</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token plain"> oldFiber </span><span class="token operator">!==</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token plain"> </span><span class="token operator">&amp;&amp;</span><span class="token plain"> newIdx </span><span class="token operator">&lt;</span><span class="token plain"> newChildren</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span><span class="token plain"> newIdx</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">oldFiber</span><span class="token punctuation">.</span><span class="token property-access">index</span><span class="token plain"> </span><span class="token operator">&gt;</span><span class="token plain"> newIdx</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    nextOldFiber </span><span class="token operator">=</span><span class="token plain"> oldFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    oldFiber </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword control-flow">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    nextOldFiber </span><span class="token operator">=</span><span class="token plain"> oldFiber</span><span class="token punctuation">.</span><span class="token property-access">sibling</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token comment">// new槽位和old槽位进行比较, 如果key不同, 返回null</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token comment">// key相同, 比较type是否一致. type一致则执行useFiber(update逻辑), type不一致则运行createXXX(insert逻辑)</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> newFiber </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">updateSlot</span><span class="token punctuation">(</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    returnFiber</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    oldFiber</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    newChildren</span><span class="token punctuation">[</span><span class="token plain">newIdx</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    lanes</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">newFiber </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token comment">// 如果返回null, 表明key不同. 无法满足公共序列条件, 退出循环</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">oldFiber </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      oldFiber </span><span class="token operator">=</span><span class="token plain"> nextOldFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">break</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">shouldTrackSideEffects</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token comment">// 若是新增节点, 则给老节点打上Deletion标记</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">oldFiber </span><span class="token operator">&amp;&amp;</span><span class="token plain"> newFiber</span><span class="token punctuation">.</span><span class="token property-access">alternate</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token function">deleteChild</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> oldFiber</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token comment">// lastPlacedIndex 记录被移动的节点索引</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token comment">// 如果当前节点可复用, 则要判断位置是否移动.</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  lastPlacedIndex </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">placeChild</span><span class="token punctuation">(</span><span class="token plain">newFiber</span><span class="token punctuation">,</span><span class="token plain"> lastPlacedIndex</span><span class="token punctuation">,</span><span class="token plain"> newIdx</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token comment">// 更新resultingFirstChild结果序列</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">previousNewFiber </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    resultingFirstChild </span><span class="token operator">=</span><span class="token plain"> newFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword control-flow">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    previousNewFiber</span><span class="token punctuation">.</span><span class="token property-access">sibling</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> newFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  previousNewFiber </span><span class="token operator">=</span><span class="token plain"> newFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  oldFiber </span><span class="token operator">=</span><span class="token plain"> nextOldFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token punctuation">}</span></div></div></pre></div><blockquote><p>第二次循环</p></blockquote><div class="dumi-default-source-code"><button type="button" class="dumi-default-source-code-copy"><svg viewBox="64 64 896 896"><path d="M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2 263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z"></path></svg></button><pre class="prism-code language-js"><div class=""><div class=""><span class="token comment">// 1. 将第一次循环后, oldFiber剩余序列加入到一个map中. 目的是为了第二次循环能顺利的找到可复用节点</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token keyword">const</span><span class="token plain"> existingChildren </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">mapRemainingChildren</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> oldFiber</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">
</span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token comment">// 2. 第二次循环: 遍历剩余非公共序列, 优先复用oldFiber序列中的节点</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token keyword control-flow">for</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token plain"> newIdx </span><span class="token operator">&lt;</span><span class="token plain"> newChildren</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span><span class="token plain"> newIdx</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> newFiber </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">updateFromMap</span><span class="token punctuation">(</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    existingChildren</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    returnFiber</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    newIdx</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    newChildren</span><span class="token punctuation">[</span><span class="token plain">newIdx</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    lanes</span><span class="token punctuation">,</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">newFiber </span><span class="token operator">!==</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">shouldTrackSideEffects</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">newFiber</span><span class="token punctuation">.</span><span class="token property-access">alternate</span><span class="token plain"> </span><span class="token operator">!==</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">        </span><span class="token comment">// 如果newFiber是通过复用创建的, 则清理map中对应的老节点</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">        existingChildren</span><span class="token punctuation">.</span><span class="token method function property-access">delete</span><span class="token punctuation">(</span><span class="token plain">newFiber</span><span class="token punctuation">.</span><span class="token property-access">key</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token plain"> </span><span class="token operator">?</span><span class="token plain"> newIdx </span><span class="token operator">:</span><span class="token plain"> newFiber</span><span class="token punctuation">.</span><span class="token property-access">key</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    lastPlacedIndex </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">placeChild</span><span class="token punctuation">(</span><span class="token plain">newFiber</span><span class="token punctuation">,</span><span class="token plain"> lastPlacedIndex</span><span class="token punctuation">,</span><span class="token plain"> newIdx</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token comment">// 更新resultingFirstChild结果序列</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">previousNewFiber </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      resultingFirstChild </span><span class="token operator">=</span><span class="token plain"> newFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword control-flow">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">      previousNewFiber</span><span class="token punctuation">.</span><span class="token property-access">sibling</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> newFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">    previousNewFiber </span><span class="token operator">=</span><span class="token plain"> newFiber</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token comment">// 3. 善后工作, 第二次循环完成之后, existingChildren中剩余的fiber节点就是将要被删除的节点, 打上Deletion标记</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">shouldTrackSideEffects</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain">  existingChildren</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token function">deleteChild</span><span class="token punctuation">(</span><span class="token plain">returnFiber</span><span class="token punctuation">,</span><span class="token plain"> child</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div></div><div class=""><div class=""><span class="token plain"></span><span class="token punctuation">}</span></div></div></pre></div><h3 id="结果"><a aria-hidden="true" tabindex="-1" href="#结果"><span class="icon icon-link"></span></a>结果<!-- --></h3><p>无论是单节点还是可迭代节点的比较, 最终的目的都是生成下级子节点. 并在<!-- --><code>reconcileChildren</code>过程中, 给一些有副作用的节点(新增, 删除, 移动位置等)打上副作用标记, 等待 commit 阶段(参考<!-- --><a href="/main/commit.md">fiber 树渲染</a>)的处理.<!-- --></p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="#总结"><span class="icon icon-link"></span></a>总结<!-- --></h2><p>本节介绍了 React 源码中, <!-- --><code>fiber构造循环</code>阶段用于生成下级子节点的<!-- --><code>reconcileChildren</code>函数(函数中的算法被称为调和算法), 并演示了<!-- --><code>可迭代节点比较</code>的图解示例. 该算法十分巧妙, 其核心逻辑把<!-- --><code>newChildren序列</code>分为 2 步遍历, 先遍历公共序列, 再遍历非公共部分, 同时复用<!-- --><code>oldFiber</code>序列中的节点.<!-- --></p></div></div><script>$RC("B:2","S:2")</script>