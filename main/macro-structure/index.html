<!DOCTYPE html><html><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="keywords" content="react, react原理, 图解react, react fiber原理, react hook原理, react 合成事件, react 基本包结构">
<meta name="description" content="图解React原理系列, 以react核心包结构和运行机制为主线索进行展开. 包括react 基本包结构, react 工作循环, react 启动模式, react fiber原理, react hook原理, react 合成事件等核心内容">
<link rel="shortcut icon" href="/km@2x.png">
<link rel="stylesheet" href="/umi.eb36fa83.css">
<title data-rh="true">宏观包结构</title>
<meta data-rh="true" property="og:title" content="宏观包结构"/><meta data-rh="true" name="description" content="React 工程目录的 packages 下包含 35 个包(@17.0.2版本).
其中与web开发相关的核心包共有 4 个, 本系列近 20 篇文章, 以这 4 个包为线索进行展开, 深入理解 react 内部作用原理."/><meta data-rh="true" property="og:description" content="React 工程目录的 packages 下包含 35 个包(@17.0.2版本).
其中与web开发相关的核心包共有 4 个, 本系列近 20 篇文章, 以这 4 个包为线索进行展开, 深入理解 react 内部作用原理."/>
</head>
<body>
<noscript><b>Enable JavaScript to run this app.</b></noscript><div id="root"><!--$?--><template id="B:0"></template><div></div><!--/$--></div><script>window.__UMI_LOADER_DATA__ = {}</script>
<script src="/umi.c14ba5aa.js"></script>

</body></html><div hidden id="S:0"><!--$?--><template id="B:1"></template><div></div><!--/$--></div><script>function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("B:0","S:0")</script><div hidden id="S:1"><div class="dumi-default-doc-layout"><div class="dumi-default-header"><div class="dumi-default-header-content"><section class="dumi-default-header-left"><a class="dumi-default-logo" href="/"><img src="/logo.png" alt="图解React"/>图解React<!-- --></a></section><section class="dumi-default-header-right"><ul class="dumi-default-navbar"><li><a class="active" href="/main/macro-structure">原理解析</a></li><li><a href="/algorithm/diff">高频算法</a></li><li><a href="/interview/01-setstate">面试题</a></li></ul><div class="dumi-default-header-right-aside"><div class="dumi-default-search-bar"><svg viewBox="64 64 896 896" class="dumi-default-search-bar-svg"><path d="M909.6 854.5 649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0 0 11.6 0l43.6-43.5a8.2 8.2 0 0 0 0-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z"></path></svg><input class="dumi-default-search-bar-input" placeholder="输入关键字搜索..."/><span class="dumi-default-search-shortcut">⌘<!-- --> K<!-- --></span></div><span class="dumi-default-color-switch" data-dumi-tooltip="亮色模式" data-dumi-tooltip-bottom="true"><svg viewBox="0 0 16 16"><path d="M8 13a1 1 0 0 1 1 1v1a1 1 0 1 1-2 0v-1a1 1 0 0 1 1-1ZM8 3a1 1 0 0 1-1-1V1a1 1 0 1 1 2 0v1a1 1 0 0 1-1 1Zm7 4a1 1 0 1 1 0 2h-1a1 1 0 1 1 0-2h1ZM3 8a1 1 0 0 1-1 1H1a1 1 0 1 1 0-2h1a1 1 0 0 1 1 1Zm9.95 3.536.707.707a1 1 0 0 1-1.414 1.414l-.707-.707a1 1 0 0 1 1.414-1.414Zm-9.9-7.072-.707-.707a1 1 0 0 1 1.414-1.414l.707.707A1 1 0 0 1 3.05 4.464Zm9.9 0a1 1 0 0 1-1.414-1.414l.707-.707a1 1 0 0 1 1.414 1.414l-.707.707Zm-9.9 7.072a1 1 0 0 1 1.414 1.414l-.707.707a1 1 0 0 1-1.414-1.414l.707-.707ZM8 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm0 6.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5Z"></path></svg><select><option value="light" selected="">亮色模式<!-- --></option><option value="dark">暗色模式<!-- --></option><option value="auto">跟随系统<!-- --></option></select></span><a class="dumi-default-icon" data-dumi-tooltip="GitHub" data-dumi-tooltip-bottom="true" target="_blank" href="https://github.com/7kms/react-illustration-series" rel="noreferrer"><svg viewBox="64 64 896 896"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></a></div></section><button type="button" class="dumi-default-header-menu-btn"><svg viewBox="64 64 896 896"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></button></div></div><div class="dumi-default-doc-layout-mobile-bar"><button type="button" class="dumi-default-sidebar-btn"><svg viewBox="64 64 896 896"><path d="M120 230h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm0 424h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm784 140H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0-424H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8z"></path></svg>侧边菜单<!-- --></button></div><main><div class="dumi-default-sidebar"><dl class="dumi-default-sidebar-group"><dt>基本概念</dt><dd><a title="宏观包结构" aria-current="page" class="active" href="/main/macro-structure">宏观包结构</a></dd><dd><a title="两大工作循环" class="" href="/main/workloop">两大工作循环</a></dd><dd><a title="高频对象" class="" href="/main/object-structure">高频对象</a></dd></dl><dl class="dumi-default-sidebar-group"><dt>运行核心</dt><dd><a title="启动过程" class="" href="/main/bootstrap">启动过程</a></dd><dd><a title="reconciler 运作流程" class="" href="/main/reconciler-workflow">reconciler 运作流程</a></dd><dd><a title="优先级管理" class="" href="/main/priority">优先级管理</a></dd><dd><a title="调度原理" class="" href="/main/scheduler">调度原理</a></dd><dd><a title="fiber 树构造(基础准备)" class="" href="/main/fibertree-prepare">fiber 树构造(基础准备)</a></dd><dd><a title="fiber 树构造(初次创建)" class="" href="/main/fibertree-create">fiber 树构造(初次创建)</a></dd><dd><a title="fiber 树构造(对比更新)" class="" href="/main/fibertree-update">fiber 树构造(对比更新)</a></dd><dd><a title="fiber 树渲染" class="" href="/main/fibertree-commit">fiber 树渲染</a></dd></dl><dl class="dumi-default-sidebar-group"><dt>状态管理</dt><dd><a title="状态与副作用" class="" href="/main/state-effects">状态与副作用</a></dd><dd><a title="Hook 原理(概览)" class="" href="/main/hook-summary">Hook 原理(概览)</a></dd><dd><a title="Hook 原理(状态Hook)" class="" href="/main/hook-state">Hook 原理(状态Hook)</a></dd><dd><a title="Hook 原理(副作用Hook)" class="" href="/main/hook-effect">Hook 原理(副作用Hook)</a></dd><dd><a title="context 原理" class="" href="/main/context">context 原理</a></dd></dl><dl class="dumi-default-sidebar-group"><dt>交互</dt><dd><a title="合成事件" class="" href="/main/synthetic-event">合成事件</a></dd></dl></div><div class="dumi-default-content"><!--$?--><template id="B:2"></template><div></div><!--/$--><div class="dumi-default-footer">Copyright © 2023 | Powered by <a href="https://d.umijs.org" target="_blank" rel="noreferrer">dumi</a></div></div></main></div></div><script>$RC("B:1","S:1")</script><div hidden id="S:2"><div class="markdown"><h1 id="react-应用的宏观包结构web-开发"><a aria-hidden="true" tabindex="-1" href="#react-应用的宏观包结构web-开发"><span class="icon icon-link"></span></a>React 应用的宏观包结构(web 开发)<!-- --></h1><blockquote><p>React 工程目录的 packages 下包含 35 个包(<!-- --><a href="https://github.com/facebook/react/tree/v17.0.2"><code>@17.0.2</code>版本<!-- --></a>).<!-- --><br/>
其中与<!-- --><code>web</code>开发相关的核心包共有 4 个, 本系列近 20 篇文章, 以这 4 个包为线索进行展开, 深入理解 react 内部作用原理.<!-- --></p></blockquote><h2 id="基础包结构"><a aria-hidden="true" tabindex="-1" href="#基础包结构"><span class="icon icon-link"></span></a>基础包结构<!-- --></h2><ol><li><p>react</p><blockquote><p>react 基础包, 只提供定义 react 组件(<!-- --><code>ReactElement</code>)的必要函数, 一般来说需要和渲染器(<!-- --><code>react-dom</code>,<!-- --><code>react-native</code>)一同使用. 在编写<!-- --><code>react</code>应用的代码时, 大部分都是调用此包的 api.<!-- --></p></blockquote></li><li><p>react-dom</p><blockquote><p>react 渲染器之一, 是 react 与 web 平台连接的桥梁(可以在浏览器和 nodejs 环境中使用), 将<!-- --><code>react-reconciler</code>中的运行结果输出到 web 界面上. 在编写<!-- --><code>react</code>应用的代码时,大多数场景下, 能用到此包的就是一个入口函数<!-- --><code>ReactDOM.render(&lt;App/&gt;, document.getElementById(&#x27;root&#x27;))</code>, 其余使用的 api, 基本是<!-- --><code>react</code>包提供的.<!-- --></p></blockquote></li><li><p>react-reconciler</p><blockquote><p>react 得以运行的核心包(综合协调<!-- --><code>react-dom</code>,<!-- --><code>react</code>,<!-- --><code>scheduler</code>各包之间的调用与配合).<!-- --><br/>
管理 react 应用状态的输入和结果的输出. 将输入信号最终转换成输出信号传递给渲染器.<!-- --></p></blockquote><ul><li>接受输入(<!-- --><code>scheduleUpdateOnFiber</code>), 将<!-- --><code>fiber</code>树生成逻辑封装到一个回调函数中(涉及<!-- --><code>fiber</code>树形结构, <!-- --><code>fiber.updateQueue</code>队列, 调和算法等),<!-- --></li><li>把此回调函数(<!-- --><code>performSyncWorkOnRoot</code>或<!-- --><code>performConcurrentWorkOnRoot</code>)送入<!-- --><code>scheduler</code>进行调度<!-- --></li><li><code>scheduler</code>会控制回调函数执行的时机, 回调函数执行完成后得到全新的 fiber 树<!-- --></li><li>再调用渲染器(如<!-- --><code>react-dom</code>, <!-- --><code>react-native</code>等)将 fiber 树形结构最终反映到界面上<!-- --></li></ul></li><li><p>scheduler</p><blockquote><p>调度机制的核心实现, 控制由<!-- --><code>react-reconciler</code>送入的回调函数的执行时机, 在<!-- --><code>concurrent</code>模式下可以实现任务分片. 在编写<!-- --><code>react</code>应用的代码时, 同样几乎不会直接用到此包提供的 api.<!-- --></p></blockquote><ul><li>核心任务就是执行回调(回调函数由<!-- --><code>react-reconciler</code>提供)<!-- --></li><li>通过控制回调函数的执行时机, 来达到任务分片的目的, 实现可中断渲染(<!-- --><code>concurrent</code>模式下才有此特性)<!-- --></li></ul></li></ol><h2 id="宏观总览"><a aria-hidden="true" tabindex="-1" href="#宏观总览"><span class="icon icon-link"></span></a>宏观总览<!-- --></h2><h3 id="架构分层"><a aria-hidden="true" tabindex="-1" href="#架构分层"><span class="icon icon-link"></span></a>架构分层<!-- --></h3><p>为了便于理解, 可将 react 应用整体结构分为接口层(<!-- --><code>api</code>)和内核层(<!-- --><code>core</code>)2 个部分<!-- --></p><ol><li><p>接口层(api)<!-- --><br/><code>react</code>包, 平时在开发过程中使用的绝大部分<!-- --><code>api</code>均来自此包(不是所有). 在<!-- --><code>react</code>启动之后, 正常可以改变渲染的基本操作有 3 个.<!-- --></p><ul><li>class 组件中使用<!-- --><code>setState()</code></li><li>function 组件里面使用 hook,并发起<!-- --><code>dispatchAction</code>去改变 hook 对象<!-- --></li><li>改变 context(其实也需要<!-- --><code>setState</code>或<!-- --><code>dispatchAction</code>的辅助才能改变)<!-- --></li></ul><p>以上<!-- --><code>setState</code>和<!-- --><code>dispatchAction</code>都由<!-- --><code>react</code>包直接暴露. 所以要想 react 工作, 基本上是调用<!-- --><code>react</code>包的 api 去与其他包进行交互.<!-- --></p></li><li><p>内核层(core)<!-- --><br/>
整个内核部分, 由 3 部分构成:<!-- --></p><ol><li>调度器<!-- --><br/><code>scheduler</code>包, 核心职责只有 1 个, 就是执行回调.
<!-- --><ul><li>把<!-- --><code>react-reconciler</code>提供的回调函数, 包装到一个任务对象中.<!-- --></li><li>在内部维护一个任务队列, 优先级高的排在最前面.</li><li>循环消费任务队列, 直到队列清空.</li></ul></li><li>构造器<!-- --><br/><code>react-reconciler</code>包, 有 3 个核心职责:
<!-- --><ol><li>装载渲染器, 渲染器必须实现<!-- --><a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/README.md#practical-examples"><code>HostConfig</code>协议<!-- --></a>(如: <!-- --><code>react-dom</code>), 保证在需要的时候, 能够正确调用渲染器的 api, 生成实际节点(如: <!-- --><code>dom</code>节点).<!-- --></li><li>接收<!-- --><code>react-dom</code>包(初次<!-- --><code>render</code>)和<!-- --><code>react</code>包(后续更新<!-- --><code>setState</code>)发起的更新请求.<!-- --></li><li>将<!-- --><code>fiber</code>树的构造过程包装在一个回调函数中, 并将此回调函数传入到<!-- --><code>scheduler</code>包等待调度.<!-- --></li></ol></li><li>渲染器<!-- --><br/><code>react-dom</code>包, 有 2 个核心职责:
<!-- --><ol><li>引导<!-- --><code>react</code>应用的启动(通过<!-- --><code>ReactDOM.render</code>).<!-- --></li><li>实现<!-- --><a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/README.md#practical-examples"><code>HostConfig</code>协议<!-- --></a>(<!-- --><a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/client/ReactDOMHostConfig.js">源码在 ReactDOMHostConfig.js 中</a>), 能够将<!-- --><code>react-reconciler</code>包构造出来的<!-- --><code>fiber</code>树表现出来, 生成 dom 节点(浏览器中), 生成字符串(ssr).<!-- --></li></ol></li></ol></li></ol><p>注意:</p><ul><li>此处分层的标准并非官方说法, 因为官方没有<!-- --><code>架构分层</code>这样的术语.<!-- --></li><li>本文只是为了深入理解 react, 在官方标准之外, 对其进行分解和剖析, 方便我们理解 react 架构.</li></ul><h3 id="内核关系"><a aria-hidden="true" tabindex="-1" href="#内核关系"><span class="icon icon-link"></span></a>内核关系<!-- --></h3><p>现将内核 3 个包的主要职责和调用关系, 绘制到一张概览图上:</p><p><img alt="" src="/static/core-packages.c2850581.png"/></p><p>注意:</p><ul><li>红色方块代表入口函数, 绿色方块代表出口函数.</li><li>package 之间的调用脉络就是通过板块间的入口和出口函数连接起来的.</li></ul><p>通过此概览图, 基本可以表述 react 内核层的宏观结构. 后面的章节, 会按照此图的思路深入到对应的模块逐一解读.</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="#总结"><span class="icon icon-link"></span></a>总结<!-- --></h2><p>本文从宏观架构的角度, 阐述了<!-- --><code>react</code>核心包之间的依赖和调用关系, 使读者对<!-- --><code>react</code>架构有简单的认识. 另外也给读者提供一个阅读源码的思路, 先整体浏览, 再深入分析, 各个击破.<!-- --></p></div></div><script>$RC("B:2","S:2")</script>